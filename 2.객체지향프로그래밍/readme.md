# 객체지향 프로그래밍(OOP: Objected Oriented Programming)

## 객체지향이란?
프로그래밍에서 필요한 데이터를 추상화시켜 **상태와 행위를 가진 객체**를 만들고 그 객체들 간의 **유기적인 상호작용**을 통해 로직을 구성하는 프로그래밍 방법

## 객체지향 언어의 특징
### 1. 캡슐화
- 객체에 필요한 데이터와 데이터를 처리하는 함수를 하나로 묶는다. 
### 2. 상속
- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다. (상위 클래스의 기능을 하위 클래스가 사용)
- 여러 객체에서 공통적으로 사용되는 코드를 하나의 클래스로 분리하여 사용할 수 있도록 하기 위함이다. 
이러한 특징은 **코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여한다.**
### 3. 다형성
- 여러 가지 형태를 가질 수 있는 능력
- 하나의 클래스나 메서드가 다양한 방식으로 동작이 가능한 것을 의미한다.
- 예) 오버로딩, 오버라이딩
### 4. 추상화
- 객체들의 공통적인 속성과 기능을 중심으로 묶는다.

## 객체지향 프로그래밍의 장단점
### 장점
---
#### 1. 코드의 재사용성이 높다.
- 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.
#### 2. 코드의 관리가 용이하다.
- 코드 간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.
#### 3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
- 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.
#### 4. 대형 프로젝트에 적합하다.
- 클래스단위로 모듈화시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러명, 여러회사에서 개발이 필요할 시 업무 분담하기 쉽다.

### 단점
---
#### 1. 설계 시 많은 시간과 노력이 필요하다.
#### 2. 처리 속도가 상대적으로 느리다.
#### 3. 객체가 많으면 용량이 커질 수도 있다.

## 오버로딩(overloading) vs 오버라이딩(overriding)
### 오버로딩
- 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것
- 기존에 없는 새로운 메서드를 정의하는 것
### 오버라이딩
- 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것

※ override의 사전적 의미는 '~위에 덮어쓰다(overwrite)'이다.

## 추상클래스 vs 인터페이스
### 추상클래스
객체를 생성할 수 없는 클래스로, 오로지 부모클래스로써의 역할만 하는 클래스
- 기본 생성자를 가진다.
- 추상 메서드, 비 추상 메서드를 포함할 수 있다.
- 추상 클래스를 상속한 클래스는 꼭 모든 메소드를 구현할 필요는 없으며, 추상 메소드만 서브 클래스 안에서 구현되면 된다.
- 객체 생성 불가하여 extends(상속)로 구현한다.

### 인터페이스
메서드 선언만 하고 구현은 되어있지 않은 템플릿
- 생성자를 가지지 않는다.
- 추상 메소드만 선언할 수 있다.
- 인터페이스를 구현하는 클래스는 인터페이스에서 선언된 모든 메소드를 다 구현해야 한다.
- 객체 생성 불가하여 implement로 구현

#### 인터페이스의 장점
#### 1. 개발시간을 단축시킬 수 있다.
- 일단 인터페이스가 작성되면, 이를 사용해서 프로그램을 작성하는 것이 가능한다. 메서드를 호출하는 쪽에서는 메서드의 내용에 관계없이 선어부만 알면 되기 때문이다.
#### 2. 표준화가 가능하다.
- 프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스를 구현하여 프로그램을 작성하도록 함으로써 보다 일관되고 정형화된 프로그램의 개발이 가능하다.
#### 3. 서로 관게없는 클래스들에게 관계를 맺어 줄 수 있다.
- 서로 상속관계에 있지도 않고, 같은 조상클래스를 가지고 있지 않은 서로 아무런 관계도 없는 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어줄 수 있다.
#### 4. 독립적인 프로그래밍이 가능하다.
- 인터페이스를 이용하면 클래스의 선언과 구현을 분리시킬 수 있기 때문에 실제구현에 독립적인 프로그램을 작성하는 것이 가능하다.

## Getter와 Setter를 사용하는 이유
**Getter**와 **Setter**를 사용하면 메서드를 통해 접근하기 때문에, 메서드 안에서 매개변수 같이 **올바르지 않은 입력값**에 대해 사전 처리할 수 있게 **제한**하거나 **조절**할 수 있습니다.

## 객체지향 설계 5원칙(SOLID)
#### 1. SRP(Single Responsibility Principle): 단일 책임 원칙
- 하나의 클래스는 하나의 책임만 가져야한다.

#### 2. OCP(Open-Closed Principle): 개방 폐쇄 원칙
- 소프트웨어 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 
변경에는 닫혀있어야 한다.

#### 3. LSP(Liskov Substitution Principle): 리스코프 치환 원칙
- 하위 클래스 및 타입들은 상위 타입들이 사용되는 곳에 대체될 수 있어야 한다.

#### 4. ISP(Interfase Segragation Principle): 인터페이스 분리 원칙
- 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스가 낫다.

#### 5. DIP(Dependency Inversion Principle): 의존관계 역전 원칙
- 추상화된 것에 의존하게 만들고 구체 클래스에 의존하도록 만들지 않는다.
=> 구현 클래스가 아니라 인터페이스에 의존
